import {
  userDataConstants,
  userWalletsConstants,
  userDepositsConstants,
  userOperationsConstants,
  userWithdrawCancelConstants,
  paymentSystemsConstants,
  withdrawRequestConstants,
  activatePlanConstants,
  activatePlanFromBalanceConstants,
  userReferralsConstants,
  changeUserDataConstants,
  changeUserPasswordConstants
} from '_constants';
import { userService } from '_services';
import { paymentSystemsService } from '_services';
import { alertActions } from '_actions';
import * as api from "_services";

export const userActions = {
  fetchUserData,
  fetchUserWallets,
  fetchUserDeposits,
  fetchUserWithdrawals,
  fetchUserReferrals,
  cancelUserWithdraw,
  withdrawRequest,
  activatePlanFromBalance,
  activatePlan,
  changePersonalData,
  changeUserPassword
};

// ЮЗЕР ИНФО

function fetchUserData() {
  return dispatch => {
    return new Promise((resolve,reject)=> {
      dispatch(request());

      userService.fetchUserData()
        .then(
          userData => {
            dispatch(success(userData));
            resolve('200');
          },
          error => {
            let message = 'Error while fetchUserData';
            dispatch(failure(message));
            dispatch(alertActions.error(message));
          }
        );
    });
  };

  function request() { return { type: userDataConstants.REQUEST } }
  function success(userData) { return { type: userDataConstants.SUCCESS, payload: userData } }
  function failure() { return { type: userDataConstants.FAILURE } }
}

// КОШЕЛЬКИ

function fetchUserWallets() {
  return dispatch => {
    return new Promise((resolve,reject)=> {
      dispatch(request());

      userService.fetchWallets()
        .then(
          wallets => {
              console.log(wallets)
            const fixedWallets = wallets.filter((el, i) => {
                console.log(el, i)
                if(el.payment_alias != 'advanced_cash') {
                    return el;
                }
            });
              console.log('fixedWallets' , fixedWallets)
            dispatch(success(fixedWallets));
            resolve('200');
          },
          error => {
            let message = 'Error while fetchUserWallets';
            dispatch(failure(message));
            dispatch(alertActions.error(message));
          }
        );
    });
  };

  function request() { return { type: userWalletsConstants.REQUEST } }
  function success(wallets) { return { type: userWalletsConstants.SUCCESS, payload: wallets } }
  function failure() { return { type: userWalletsConstants.FAILURE } }
}

// deposits

function fetchUserDeposits() {
  return dispatch => {
    return new Promise((resolve,reject)=> {
      dispatch(request());

      userService.fetchDeposits()
        .then(
          deposits => {
            dispatch(success(deposits));
            resolve('200');
          },
          error => {
            let message = 'Error while fetchUserDeposits';
            dispatch(failure(message));
            dispatch(alertActions.error(message));
          }
        );
    });
  };

  function request() { return { type: userDepositsConstants.REQUEST } }
  function success(deposits) { return { type: userDepositsConstants.SUCCESS, payload: deposits } }
  function failure() { return { type: userDepositsConstants.FAILURE } }
}

// Withdrawals

function fetchUserWithdrawals() {
  return dispatch => {
    return new Promise((resolve,reject)=> {
      dispatch(request());

      userService.fetchOperations()
        .then(
          withdrawals => {
            dispatch(success(withdrawals));
            resolve('200');
          },
          error => {
            let message = 'Error while fetchUserWithdrawals';
            dispatch(failure(message));
            dispatch(alertActions.error(message));
          }
        );
    });
  };

  function request() { return { type: userOperationsConstants.REQUEST } }
  function success(withdrawals) { return { type: userOperationsConstants.SUCCESS, payload: withdrawals } }
  function failure() { return { type: userOperationsConstants.FAILURE } }
}

// Referrals

function fetchUserReferrals() {
  return dispatch => {
    return new Promise((resolve,reject)=> {
      dispatch(request());

      userService.fetchReferrals()
        .then(
          referrals => {
            dispatch(success(referrals));
            resolve('200');
          },
          error => {
            let message = 'Error while fetchUserReferrals';
            dispatch(failure(message));
            dispatch(alertActions.error(message));
          }
        );
    });
  };

  function request() { return { type: userReferralsConstants.REQUEST } }
  function success(referrals) { return { type: userReferralsConstants.SUCCESS, payload: referrals } }
  function failure() { return { type: userReferralsConstants.FAILURE } }
}


// cancel withdraw

function cancelUserWithdraw(payload, index) {
  return dispatch => {
    return new Promise((resolve,reject)=> {
      dispatch(request());

      userService.cancelWithdraw(payload)
        .then(
          result => {
            dispatch(success(index));
            dispatch(alertActions.success(result));
            resolve('200');
          },
          error => {
            let message = 'Error while cancelUserWithdraw';
            dispatch(failure(message));
            dispatch(alertActions.error(message));
          }
        );
    });
  };

  function request() { return { type: userWithdrawCancelConstants.REQUEST } }
  function success(index) { return { type: userWithdrawCancelConstants.SUCCESS, payload: index} }
  function failure() { return { type: userWithdrawCancelConstants.FAILURE } }
}



function withdrawRequest(payload) {
  return dispatch => {
    return new Promise((resolve,reject)=> {
      dispatch(request());

      userService.withdrawRequest(payload)
        .then(
          withdraw => {
            dispatch(success());
            dispatch(alertActions.success('The withdrawal request was added to the queue'));
            dispatch(newOperation(withdraw));
            resolve('200');
          },
          error => {
            let message = 'Error while withdrawRequest';
            dispatch(failure());
            dispatch(alertActions.error(message));
          }
        );
    });
  };

  function request() { return { type: withdrawRequestConstants.REQUEST } }
  function newOperation(payload) { return { type: userOperationsConstants.NEW_OPERATION, payload: payload } }
  function success() { return { type: withdrawRequestConstants.SUCCESS } }
  function failure() { return { type: withdrawRequestConstants.FAILURE } }
}

function activatePlanFromBalance(payload) {
  return dispatch => {
    return new Promise((resolve,reject)=> {
      dispatch(request());

      userService.activatePlanFromBalanceRequest(payload)
        .then(
          plan => {
            dispatch(success());
            dispatch(alertActions.success('The plan successfully activated'));
            dispatch(dispatchNewPlan(plan));
            resolve('200');
          },
          error => {
            let message = 'Error while activatePlanFromBalance';
            dispatch(failure());
            dispatch(alertActions.error(message));
          }
        );
    });
  };

  function dispatchNewPlan(plan) { return { type: userDepositsConstants.NEW_PLAN, payload: plan } }
  function request() { return { type: activatePlanFromBalanceConstants.REQUEST } }
  function success() { return { type: activatePlanFromBalanceConstants.SUCCESS } }
  function failure() { return { type: activatePlanFromBalanceConstants.FAILURE } }
}

function activatePlan(payload) {
  return dispatch => {
    return new Promise((resolve,reject)=> {
      dispatch(request());

      userService.withdrawRequest(payload)
        .then(
          withdraw => {
            dispatch(success());
            dispatch(alertActions.success('The plan successfully activated'));
            resolve('200');
          },
          error => {
            let message = 'Error while activatePlan';
            dispatch(failure());
            dispatch(alertActions.error(message));
          }
        );
    });
  };

  function request() { return { type: activatePlanConstants.REQUEST } }
  function success() { return { type: activatePlanConstants.SUCCESS } }
  function failure() { return { type: activatePlanConstants.FAILURE } }
}

function changePersonalData(payload) {
  return dispatch => {
    return new Promise((resolve,reject)=> {
      dispatch(request());
      api.userService.changePersonalData(payload)
        .then(
          withdraw => {
            dispatch(alertActions.success('Your user data was successfully changed'));
          },
          error => {
            let errorsObj = error.data.error;
            // let message = 'Error while changing personal data';
            let message = errorsObj[Object.keys(errorsObj)[0]][0];
            dispatch(failure());
            dispatch(alertActions.error(message));
          }
        );
    });
  };

  function request() { return { type: changeUserDataConstants.REQUEST } }
  function success() { return { type: changeUserDataConstants.SUCCESS } }
  function failure() { return { type: changeUserDataConstants.FAILURE } }
}

function changeUserPassword(payload) {
  return dispatch => {
    return new Promise((resolve,reject)=> {
      dispatch(request());
      api.userService.changePassword(payload)
        .then(
          withdraw => {
            dispatch(alertActions.success('Your password was successfully changed'));
          },
          error => {
            let errorsObj = error.data.error;
            // let message = 'Error while changing password';
            debugger
            let message = errorsObj[Object.keys(errorsObj)[0]][0];
            dispatch(alertActions.error(message));
          }
        );
    });
  };

  function request() { return { type: changeUserPasswordConstants.REQUEST } }
}